---
output:
  reprex::reprex_document:
    venue: "gh"
    advertise: FALSE
    session_info: TRUE
    style: TRUE
    comment: "#;-)"
    tidyverse_quiet: FALSE
    std_out_err: TRUE
knit: reprex::reprex_render
---

# Introduction

This study is a part of Google Data Analytics Professional Certificate. The goal is to analyze the Divvy bike-share program following the six steps of the data analysis process: ask, prepare, process, analyze, share, and act. 
The study will take from january of 2024 to january of 2025 as the time frame to analyze the data.

```{r}
## Load libraries
library(tidyverse)
library(DBI)
library(RMySQL)
```

# Prepare

## Data Sources

The data used in this study is from the Divvy bike-share program in Chicago. The data is available in CSV format and can be downloaded from the following links: [Datasets](https://divvy-tripdata.s3.amazonaws.com/index.html). 
The data is divided into one file for each month and includes information about the start and end time of the trip, the start and end stations, the duration of the trip, and the user type.
I will use SQL to merge all data, so will be easier to analyze the data. All file will be downloaded and saved in the same folder as the script.

```{r}
## Run /DB/data_wrangle.r
source("DB/data_wrangle.r")
```

## Quiet tidyverse

The tidyverse meta-package is quite chatty at startup, which can be very useful in exploratory, interactive work. It is often less useful in a reprex, so by default, we suppress this.

However, when `tidyverse_quiet` is `FALSE`, the rendered result will include a tidyverse startup message about package versions and function masking.

## Chunks in languages other than R

Remember: knitr supports many other languages than R, so you can reprex bits of code in Python, Ruby, Julia, C++, SQL, and more. Note that, in many cases, this still requires that you have the relevant external interpreter installed.

Let's try Python!

```{python, eval = Sys.which("python") != "", python.reticulate = requireNamespace("reticulate", quietly = TRUE)}
x = 'hello, python world!'
print(x.split(' '))
```

And bash!

```{bash, eval = Sys.which("bash") != ""}
echo "Hello Bash!";
pwd;
ls | head;
```

Write a function in C++, use Rcpp to wrap it and ...

```{Rcpp, eval = requireNamespace("Rcpp", quietly = TRUE)}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
  return x * 2;
}
```

then immediately call your C++ function from R!

```{r, eval = requireNamespace("Rcpp", quietly = TRUE)}
timesTwo(1:4)
```

## Standard output and error

Some output that you see in an interactive session is not actually captured by rmarkdown, when that same code is executed in the context of an `.Rmd` document. When `std_out_err` is `TRUE`, `reprex::reprex_render()` uses a feature of `callr:r()` to capture such output and then injects it into the rendered result.

Look for this output in a special section of the rendered document (and notice that it does not appear right here).

```{r}
system2("echo", args = "Output that would normally be lost")
```

## Session info

Because `session_info` is `TRUE`, the rendered result includes session info, even though no such code is included here in the source document. 
